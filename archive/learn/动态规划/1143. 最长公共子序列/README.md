1143. 最长公共子序列

```
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

示例 1：

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
示例 2：

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
示例 3：

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-common-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

# 暴力解
列举出两个字符串所有的子序列，然后找出重合子串，然后选择一个最长的长度作为解返回

# 思路点
是不要考虑整个字符串，而是细化到s1和s2的每个字符

定义函数dp(s1, i, s2, j)，代表s1[i:]与s2[j:]这两个字符串的最长公共子序列长度
我们要的解就是dp(s1, 0, s2, 0)
如果s1[0] == s2[0] 那么很好理解，其解为
    dp(s1, 1, s2, 1) + 1 if s1[0] == s2[0]

如果是s1[0] != s2[0]的情况，其可能对应到三种情况
s1[0] 在s2的后续子串中
s2[0] 在s1的后续子串中
s1[0] 和s2[0] 都是独一份，不在另一个字符串中存在

不过我们也不知道是哪种，情况，所以就都算一遍。。
    max(dp(s1, 0, s2, 1), dp(s1, 1, s2, 0), dp(s1, 1, s2, 1))

不过情况三的解肯定是小于等于情况一或情况二的,或者说是被包含在情况一二中的，所以不用计算

递推的式子为
if s1[0] == s2[0]
    dp(s1, i, s2, j) = dp(s1, i+1, s2, j + 1) + 1
else
    dp(s1, i, s2, j) = max(
        dp(s1, i+1, s2, j),
        dp(s1, i, s2, j+1)
    )

# 自底向上

定义s1[0..i-1]与s2[0..j-1]的lcs长度为dp[i][j]

bad case为 dp[0][...] = dp[..][0] = 0

